---
title: A custom R function for transposing data.tables
author: Dave Clark
date: '2019-02-28'
slug: a-custom-r-function-for-transposing-data-tables
categories: []
tags: []
image:
  caption: ''
  focal_point: ''
---



<p>The <code>data.table</code> package has become my favourite <code>R</code> package for all things data handling. Unlike the “tidyverse” suite of packages, the syntax is more akin to base <code>data.frame</code> syntax, meaning I was able to pick it up quite quickly. It is also incredibly quick, and the parallel data import/export functions (<code>fread</code> &amp; <code>fwrite</code>) are a real gift for working with larger data tables, like OTU tables, which can contain several hundred columns, and many thousands of rows. The only thing I found <code>data.table</code> lacked was a function to transpose data in a convenient way.</p>
<p>Let me demonstrate what I mean with some examples. Let’s load a small toy dataset that is topologically similar to an OTU table (e.g. samples as cols, species abundances as rows).</p>
<pre class="r"><code># load data.table and vegan packages
library(data.table)
library(vegan)</code></pre>
<pre><code>## Loading required package: permute</code></pre>
<pre><code>## Loading required package: lattice</code></pre>
<pre><code>## This is vegan 2.5-6</code></pre>
<pre class="r"><code># load the Barro Colorado Island tree dataset
data(BCI)

# coerce to a data.table
# keep the rownames, as this we&#39;ll use this as a &#39;sample&#39; column
bci &lt;- as.data.table(BCI, keep.rownames = T)

# make more realistic sample names and delete old col
bci[, &quot;:=&quot;(sampleName = paste0(&quot;sample_&quot;, rn), rn = NULL)]</code></pre>
<p>Now the data represent something comparable to the OTU tables I am used to working with. Species are columns, whilst each row represents a sample. However, it is common to want to work with the data in the opposite format, with samples as columns and species as rows. Intuitively, one would normally transpose the data using the <code>t</code> function.</p>
<pre class="r"><code>transBci &lt;- t(bci)

str(transBci)</code></pre>
<pre><code>##  chr [1:226, 1:50] &quot;0&quot; &quot;0&quot; &quot;0&quot; &quot;0&quot; &quot; 0&quot; &quot;0&quot; &quot; 2&quot; &quot;0&quot; &quot;0&quot; &quot;0&quot; &quot;25&quot; &quot;0&quot; ...
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : chr [1:226] &quot;Abarema.macradenia&quot; &quot;Vachellia.melanoceras&quot; &quot;Acalypha.diversifolia&quot; &quot;Acalypha.macrostachya&quot; ...
##   ..$ : NULL</code></pre>
<p>However, as you can see, this causes problems. Having a sample column present in our data means that all the counts get coerced to character class when transposed. Plus, we’d have to manually set the sample row as our new column names, and then delete it from the data.</p>
<p>An alternate solution involves using <code>melt</code> and <code>dcast</code> functions to transpose the data…</p>
<pre class="r"><code>transBci2 &lt;- dcast(melt(bci, id.vars = &quot;sampleName&quot;), variable ~ sampleName)

str(transBci2)</code></pre>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:   225 obs. of  51 variables:
##  $ variable : Factor w/ 225 levels &quot;Abarema.macradenia&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
##  $ sample_1 : int  0 0 0 0 0 0 2 0 0 0 ...
##  $ sample_10: int  1 0 0 0 0 1 2 0 0 0 ...
##  $ sample_11: int  0 0 0 0 0 0 10 0 0 0 ...
##  $ sample_12: int  0 0 0 0 1 1 3 0 0 2 ...
##  $ sample_13: int  0 0 0 0 1 1 1 0 1 1 ...
##  $ sample_14: int  0 0 0 0 0 0 4 0 0 0 ...
##  $ sample_15: int  0 0 0 0 2 0 2 0 0 0 ...
##  $ sample_16: int  0 0 0 0 2 0 2 0 0 3 ...
##  $ sample_17: int  0 0 0 0 0 1 2 0 0 2 ...
##  $ sample_18: int  0 0 0 0 1 1 0 0 0 0 ...
##  $ sample_19: int  0 0 0 0 0 1 1 0 0 1 ...
##  $ sample_2 : int  0 0 0 0 0 0 1 0 0 0 ...
##  $ sample_20: int  0 0 0 0 0 2 2 0 0 0 ...
##  $ sample_21: int  0 0 0 0 0 1 2 0 0 1 ...
##  $ sample_22: int  0 0 0 0 1 0 4 0 0 4 ...
##  $ sample_23: int  0 0 0 0 0 0 1 0 0 0 ...
##  $ sample_24: int  0 0 0 0 2 1 0 0 0 1 ...
##  $ sample_25: int  0 0 0 0 0 1 2 0 0 0 ...
##  $ sample_26: int  0 0 0 0 0 0 3 0 0 0 ...
##  $ sample_27: int  0 0 0 0 1 4 3 0 0 3 ...
##  $ sample_28: int  0 2 0 1 0 1 2 0 0 0 ...
##  $ sample_29: int  0 0 0 0 1 0 1 0 0 0 ...
##  $ sample_3 : int  0 0 0 0 0 0 2 0 0 0 ...
##  $ sample_30: int  0 0 0 0 14 2 6 0 0 0 ...
##  $ sample_31: int  0 0 0 0 5 0 4 0 0 0 ...
##  $ sample_32: int  0 1 0 0 7 0 6 0 0 0 ...
##  $ sample_33: int  0 0 0 0 3 1 3 0 0 1 ...
##  $ sample_34: int  0 0 1 0 3 0 5 0 0 0 ...
##  $ sample_35: int  0 0 0 0 6 0 8 0 0 0 ...
##  $ sample_36: int  0 0 0 0 1 0 3 0 0 0 ...
##  $ sample_37: int  0 0 0 0 2 0 4 0 0 0 ...
##  $ sample_38: int  0 0 0 0 6 0 2 0 0 1 ...
##  $ sample_39: int  0 0 0 0 9 0 3 0 0 1 ...
##  $ sample_4 : int  0 0 0 0 3 0 18 0 0 0 ...
##  $ sample_40: int  0 0 1 0 7 0 3 0 0 1 ...
##  $ sample_41: int  0 0 0 0 0 1 11 0 0 0 ...
##  $ sample_42: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ sample_43: int  0 0 0 0 0 1 3 0 0 0 ...
##  $ sample_44: int  0 0 0 0 4 0 4 0 0 0 ...
##  $ sample_45: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ sample_46: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ sample_47: int  0 0 0 0 2 0 1 0 0 1 ...
##  $ sample_48: int  0 0 0 0 1 0 3 0 0 1 ...
##  $ sample_49: int  0 0 0 0 0 0 6 0 0 1 ...
##  $ sample_5 : int  0 0 0 0 1 1 3 0 0 1 ...
##  $ sample_50: int  0 0 0 0 1 0 2 0 0 1 ...
##  $ sample_6 : int  0 0 0 0 0 0 2 1 0 0 ...
##  $ sample_7 : int  0 0 0 0 0 1 0 0 0 0 ...
##  $ sample_8 : int  0 0 0 0 0 0 2 0 0 0 ...
##  $ sample_9 : int  0 0 0 0 5 0 2 0 0 0 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 
##  - attr(*, &quot;sorted&quot;)= chr &quot;variable&quot;</code></pre>
<p>That’s better: the sample names are now in the correct place, we have a column with the species names, and the data have remained in the correct integer class. However, whilst that code may have run quite quickly, much larger datasets can slow it down. I therefore wrote a little function based on the original transpose function to get the same result as above, but quicker!</p>
<p>The function is called <code>transDT</code> and can be found in my GitHub hosted package, <code>ecolFudge</code>.</p>
<pre class="r"><code># first install my package from github
library(devtools)

install_github(&quot;dave-clark/ecolFudge&quot;)

# load ecolFudge package
library(ecolFudge)

# view the transDT function
transDT</code></pre>
<pre><code>## function (dt, transCol, rowID) 
## {
##     newRowNames &lt;- colnames(dt)
##     newColNames &lt;- dt[, transCol, with = F]
##     transposedDt &lt;- transpose(dt[, !colnames(dt) %in% transCol, 
##         with = F])
##     colnames(transposedDt) &lt;- unlist(newColNames)
##     transposedDt[, rowID] &lt;- newRowNames[newRowNames != transCol]
##     return(transposedDt)
## }
## &lt;bytecode: 0x55a327d52c50&gt;
## &lt;environment: namespace:ecolFudge&gt;</code></pre>
<p>As you can see, the function takes three arguments. The first, <code>dt</code>, is simply the data.table you wish to transpose. The second, <code>transCol</code>, is the column that you wish to become your new column names. In our example, this would be the <code>sampleName</code> column. The third argument, <code>rowID</code>, is simply the name you would like to call the column with your new row identifiers (e.g. the column names in your original data). In this example, our new row identifiers are the names of the species, and so it makes sense to call this column <code>species</code> or something similar.</p>
<pre class="r"><code>transBci3 &lt;- transDT(bci, transCol=&quot;sampleName&quot;, rowID = &quot;species&quot;)

# note that the species column has been placed as the last column...
str(transBci3)</code></pre>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:   225 obs. of  51 variables:
##  $ sample_1 : int  0 0 0 0 0 0 2 0 0 0 ...
##  $ sample_2 : int  0 0 0 0 0 0 1 0 0 0 ...
##  $ sample_3 : int  0 0 0 0 0 0 2 0 0 0 ...
##  $ sample_4 : int  0 0 0 0 3 0 18 0 0 0 ...
##  $ sample_5 : int  0 0 0 0 1 1 3 0 0 1 ...
##  $ sample_6 : int  0 0 0 0 0 0 2 1 0 0 ...
##  $ sample_7 : int  0 0 0 0 0 1 0 0 0 0 ...
##  $ sample_8 : int  0 0 0 0 0 0 2 0 0 0 ...
##  $ sample_9 : int  0 0 0 0 5 0 2 0 0 0 ...
##  $ sample_10: int  1 0 0 0 0 1 2 0 0 0 ...
##  $ sample_11: int  0 0 0 0 0 0 10 0 0 0 ...
##  $ sample_12: int  0 0 0 0 1 1 3 0 0 2 ...
##  $ sample_13: int  0 0 0 0 1 1 1 0 1 1 ...
##  $ sample_14: int  0 0 0 0 0 0 4 0 0 0 ...
##  $ sample_15: int  0 0 0 0 2 0 2 0 0 0 ...
##  $ sample_16: int  0 0 0 0 2 0 2 0 0 3 ...
##  $ sample_17: int  0 0 0 0 0 1 2 0 0 2 ...
##  $ sample_18: int  0 0 0 0 1 1 0 0 0 0 ...
##  $ sample_19: int  0 0 0 0 0 1 1 0 0 1 ...
##  $ sample_20: int  0 0 0 0 0 2 2 0 0 0 ...
##  $ sample_21: int  0 0 0 0 0 1 2 0 0 1 ...
##  $ sample_22: int  0 0 0 0 1 0 4 0 0 4 ...
##  $ sample_23: int  0 0 0 0 0 0 1 0 0 0 ...
##  $ sample_24: int  0 0 0 0 2 1 0 0 0 1 ...
##  $ sample_25: int  0 0 0 0 0 1 2 0 0 0 ...
##  $ sample_26: int  0 0 0 0 0 0 3 0 0 0 ...
##  $ sample_27: int  0 0 0 0 1 4 3 0 0 3 ...
##  $ sample_28: int  0 2 0 1 0 1 2 0 0 0 ...
##  $ sample_29: int  0 0 0 0 1 0 1 0 0 0 ...
##  $ sample_30: int  0 0 0 0 14 2 6 0 0 0 ...
##  $ sample_31: int  0 0 0 0 5 0 4 0 0 0 ...
##  $ sample_32: int  0 1 0 0 7 0 6 0 0 0 ...
##  $ sample_33: int  0 0 0 0 3 1 3 0 0 1 ...
##  $ sample_34: int  0 0 1 0 3 0 5 0 0 0 ...
##  $ sample_35: int  0 0 0 0 6 0 8 0 0 0 ...
##  $ sample_36: int  0 0 0 0 1 0 3 0 0 0 ...
##  $ sample_37: int  0 0 0 0 2 0 4 0 0 0 ...
##  $ sample_38: int  0 0 0 0 6 0 2 0 0 1 ...
##  $ sample_39: int  0 0 0 0 9 0 3 0 0 1 ...
##  $ sample_40: int  0 0 1 0 7 0 3 0 0 1 ...
##  $ sample_41: int  0 0 0 0 0 1 11 0 0 0 ...
##  $ sample_42: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ sample_43: int  0 0 0 0 0 1 3 0 0 0 ...
##  $ sample_44: int  0 0 0 0 4 0 4 0 0 0 ...
##  $ sample_45: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ sample_46: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ sample_47: int  0 0 0 0 2 0 1 0 0 1 ...
##  $ sample_48: int  0 0 0 0 1 0 3 0 0 1 ...
##  $ sample_49: int  0 0 0 0 0 0 6 0 0 1 ...
##  $ sample_50: int  0 0 0 0 1 0 2 0 0 1 ...
##  $ species  : chr  &quot;Abarema.macradenia&quot; &quot;Vachellia.melanoceras&quot; &quot;Acalypha.diversifolia&quot; &quot;Acalypha.macrostachya&quot; ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>Now let’s see whether the <code>transDT</code> function can be faster than the <code>dcast/melt</code> method…</p>
<pre class="r"><code>library(microbenchmark)

speedTest &lt;- microbenchmark(
  transDT(bci, transCol = &quot;sampleName&quot;, rowID = &quot;species&quot;),
  dcast(melt(bci, id.vars = &quot;sampleName&quot;), variable ~ sampleName),
  times = 50)

# rename factor levels to neaten up results plot
speedTest$expr &lt;- factor(speedTest$expr,
  levels = levels(speedTest$expr),
  labels = c(&quot;transDT&quot;, &quot;dcast/melt&quot;))

boxplot(time/1000 ~ expr,
  data = speedTest,
  ylab = expression(paste(&quot;Time (&quot;, mu, &quot;S)&quot;)),
  xlab = &quot;Method&quot;)</code></pre>
<p><img src="/post/2019-02-28-a-custom-r-function-for-transposing-data-tables_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>There you have it, transDT gives us the same result, but in a fraction of the time compared to the <code>dcast/melt</code> method, even on a relatively small dataset. I hope this is useful to other <code>R</code> users other than myself, if you have any questions, do get in touch!</p>
